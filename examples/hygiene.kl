#lang "prelude.kl"

(import (shift "prelude.kl" 1))
(import (shift "quasiquote.kl" 1))
(import "define-syntax-rule.kl")


-- Klister's macro system is "hygienic", meaning that it automatically prevents
-- accidental variable capture. For example, in the code below, variables
-- defined at the macro's call site are not accidentally captured by the
-- variables uses in the code generated by the "should-not-be-captured" macro.

(define first (lambda (x y) x))
(define second (lambda (x y) y))

(define fun first)

(define-syntax-rule (should-not-be-captured)
  fun)

(define fun second)

(example (fun 'a 'b))                       -- (1)
(example ((should-not-be-captured) 'a 'b))  -- (2)

-- The function "fun" is defined twice: first as a function which returns its
-- first argument, and then as a function which returns its second argument.
-- The second definition shadows the first, thus on line (1), "fun" returns its
-- second argument.
--
-- Between the two definition of "fun", a macro "should-not-be-captured" is
-- defined. It is a very simple macro which always expands to the symbol 'fun.
-- Thus, line (2) expands to (fun 'a 'b), same as line (1). And yet, thanks to
-- hygiene, this time the symbol "fun" refers to the first definition, the one
-- which was in scope when the macro was defined! This allows the user to
-- redefine a common identifier such as "case" or "lambda" without accidentally
-- changing the semantics of all the macros macros which produce code
-- containing those symbols.


-- The following example demonstrates another kind of accidental variable
-- capture. Thanks to hygiene, the variables bound by the code generated by the
-- macro are not accidentally captured by the variable uses in the code at the
-- macro's call site, even if those variable uses are passed to the macro and
-- incorporated in the generated code.

(define-syntax-rule (should-not-capture var)
  (lambda (fun) var))

(example
  ((should-not-capture fun) first 'a 'b))

-- The macro "should-not-capture" is defined so that (should-not-capture x)
-- always expands to the constant function which always returns x. Always, even
-- in the case (should-not-capture fun), which naively seems like it should
-- return (lambda (fun) fun), the identify function. If it was the identity
-- function, then ((should-not-capture fun) first) would behave like "first", but
-- thanks to hygiene, the "fun" in the body still refers to "second", and so
-- ((should-not-capture fun) first) behaves like "second".
--
-- This allows the macro to define helper variables with short names like "x"
-- or "fun" in their generated code, without worrying about what happens if the
-- caller also happens to use these same common variable names for a different
-- purpose.
