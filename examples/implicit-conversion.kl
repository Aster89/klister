#lang "prelude.kl"

(import (shift "prelude.kl" 1))
(import (shift "quasiquote.kl" 1))
(import (shift "reader.kl" 1))
(import "define-syntax-rule.kl")
(import "monad.kl")
(import "pair-datatype.kl")
(import "reader.kl")


(define-macro (my-example body)
  (pure `(example
           (run-reader ,body (unit)))))

(define-macro (let-implicit reader-f body)
  (pure `(reader-do
           (<- r ask)
           (let [f (run-reader ,reader-f r)]
             (local (lambda (implicits)
                      (pair f implicits))
               ,body)))))

(defun reader-ap-with (r2a2b reader-b2c reader-a)
  (reader
    (lambda (r)
      ((run-reader reader-b2c r)
       (r2a2b r (run-reader reader-a r))))))

(define-macro (pick-reader-ap-variant)
  (let [type-eq?
        (lambda (t1 t2)
          (type-case t1
            [String
             (type-case t2
              [String (pure true)]
              [(else _) (pure false)])]
            [Integer
             (type-case t2
              [Integer (pure true)]
              [(else _) (pure false)])]))]
    (>>= (which-problem)
         (lambda (prob)
            (case prob
              [(expression t)
               (type-case t
                 [(-> reader-f reader-a-to-reader-b)
                  (type-case reader-a-to-reader-b
                    [(-> reader-a reader-b)
                     (type-case reader-f
                       [(Reader rF e-to-b)
                        (type-case e-to-b
                          [(-> e b)
                           (type-case reader-a
                             [(Reader rA a)
                              -- "a" for "actual", "e" for "expected".
                              -- If the actual type doesn't match the
                              -- expected type, look for a conversion
                              -- function in "r".
                              (>>= (type-eq? a e)
                                   (lambda (eq?)
                                     (case eq?
                                       [(true)
                                        (pure 'reader-ap)]
                                       [(false)
                                        -- TODO: actually look through "r"
                                        -- instead of assuming there's only
                                        -- one function in "r".
                                        (pure '(reader-ap-with (lambda (pair-f-unit)
                                                                 (case pair-f-unit
                                                                   [(pair f (unit))
                                                                    f]))))])))])])])])])])))))

(define-macros
  ([my-app (lambda (stx)
             (flet (go (f args)
                     (syntax-case args
                       [(list (x))
                        (pure `(#%app (pick-reader-ap-variant) ,f ,x))]
                       [(cons x xs)
                        (go `(#%app (pick-reader-ap-variant) ,f ,x) xs)]))
               (syntax-case stx
                 [(cons _ f-and-args)
                  (syntax-case f-and-args
                    [(cons f args)
                     (go f args)])])))]))

(define-macro (my-integer-literal n)
  (pure `(reader-pure (#%integer-literal ,n))))

(define-macro (my-string-literal s)
  (pure `(reader-pure (#%string-literal ,s))))

(define my-+
  (reader-pure +))

(define my-string-length
  (reader-pure string-length))

(export (rename ([my-app #%app]
                 [my-integer-literal #%integer-literal]
                 [my-string-literal #%string-literal]
                 [my-example example]
                 [my-+ +]
                 [my-string-length string-length])
                #%module
                my-app
                my-integer-literal
                my-string-literal
                my-example
                let-implicit
                my-+
                my-string-length))
