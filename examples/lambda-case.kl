#lang "prelude.kl"

(import (shift "prelude.kl" 1))
(import (shift "quasiquote.kl" 1))
(import "list.kl")

-- In Haskell, the LambdaCase language extension allows us to write
--
--     \case
--       [] -> "nil"
--       _:_ -> "cons"
--
-- instead of
--
--     \x -> case x of
--       [] -> "nil"
--       _:_ -> "cons"
--
-- This is nice, but syntactic extensions like LambdaCase are few and far
-- between. In Klister, you can implement syntactic extensions yourself, so you
-- can have as much syntactic sugar as you want. Here is how to implement
-- lambda-case.

(define-macros
  -- (lambda-case                                                   -- (1)
  --   [(nil) "nil"]
  --   [(:: _ _) "cons"])
  -- =>
  -- (lambda (x)                                                    -- (2)
  --   (case x
  --     [(nil) "nil"]
  --     [(:: _ _) "cons"]))
  ([lambda-case
    (lambda (stx)                                                   -- (3)
      (case (open-syntax stx)                                       -- (4)
        [(list-contents (:: _ cases))                               -- (5)
         (pure                                                      -- (6)
           `(lambda (x)
              ,(close-syntax stx stx                                -- (7)
                 (list-contents (:: 'case (:: 'x cases))))))]))]))

(example                                                            -- (8)
  (let [f (lambda-case
            [(nil) "nil"]
            [(:: _ _) "cons"])]
    (f (list 1 2 3))))

-- We define a "macro" named "lambda-case". We want lambda-case to receive a
-- list of cases, as in the example input at (1), and to behave like a lambda
-- which calls "case" on that list of cases, as in the example output at (2).
-- We say that the input code _expands_ to the output code.
--
-- A macro is implemented as a function of type (-> Syntax (Macro Syntax)), the
-- lambda at (3). The input Syntax, given below, includes the "lambda-case"
-- symbol in the head position.
--
--     '(lambda-case
--        [(nil) "nil"]
--        [(:: _ _) "cons"])
--
-- The Syntax above wraps a list of three smaller syntax objects:
--
--     (list 'lambda-case
--           '[(nil) "nil"]
--           '[(:: _ _) "cons"])
--
-- One line (4), we "open" the syntax object in order to forget its source
-- location and lexical information, and match on the list within. On line (5),
-- we drop the "lambda-case" from the function position and keep the list of
-- cases for later.
--
-- We don't need any of the Macro monad's side effects, so on line (6), we
-- are already ready to construct and return a Syntax. As a reminder, here is
-- our target output again.
--
--     '(lambda (x)
--        (case x
--          [(nil) "nil"]
--          [(:: _ _) "cons"]))
--
-- One line (7), we want to construct the following syntax object.
--
--     '(case x
--        [(nil) "nil"]
--        [(:: _ _) "cons"])
--
-- The Syntax above wraps a list of four smaller syntax objects:
--
--     (list 'case
--           'x
--           '[(nil) "nil"]
--           '[(:: _ _) "cons"])
--
-- Which we must then "close", by attaching to this list the source location
-- and lexical information from some other Syntax object.
--
-- Finally, on line (8), we exercise our macro using an example. The output of
-- the example can be seen by running this file:
--
--     $ cabal run klister -- run examples/lambda-case.kl
--     Example at lambda-case.kl:42.1-97.1:
--       let f = λx. case x of { nil ↦ "nil" ; :: _ _ ↦ "cons" } in
--         (f (:: 1 (:: 2 (:: 3 nil)))) :
--         String ↦
--       "cons"
--
-- Or by looking at the golden file generated by our test suite:
--
--     $ cat examples/lambda-case.golden
--     "cons" : String

(export lambda-case)
